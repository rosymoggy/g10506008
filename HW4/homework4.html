<html>
<head>
	<title>HW4 seek</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

</style>
</head>
<body>
<div id="info">
<a href="../index.html">Back</a><br/>
hw4 helper
<button id="whoSeek" onclick="who()">
User
</button>
</div>
<script>
var camera, scene, renderer, controls;
var puck;
var agents = [];
var agentNumber = 7;
var blocks = [];
var blockNumber = 5;
var angle = 0;
var targetCatch = false;
var targetOmega = 0.3;

var mass = 1;
var clock = new THREE.Clock();

var pickables = [];
var raycaster;
var mouse = new THREE.Vector2();

var target = new THREE.Vector3();

var planeSize = 150;

function abs (num) {
	return num < 0 ? -num : num;
}

var Agent = function(mesh, initPos) {
  this.pos = new THREE.Vector3();
  if (initPos) this.pos.copy(initPos);

  this.vel = new THREE.Vector3();
  this.force = new THREE.Vector3();
  this.target = new THREE.Vector3();
  this.angle = 0
  this.mesh = mesh;
  this.maxSpeed = 60;
  this.maxForce = 60;

  this.setTarget = function(target) {
    this.target.copy(target);
  }

  this.update = function(dt) {
    // compute force
    this.force = this.target.clone().sub(this.pos).setLength(this.maxSpeed).sub(this.vel);


    // collision avoidance
    // (for each obstacle)
    for (var i=0; i<blockNumber; i++) {
    	if(blocks[i].obj.position === this.pos) {
    		continue;
    	}
	    var tmp = blocks[i].obj.position.clone().sub(this.pos);
	    var tmpProj = tmp.clone().projectOnVector(this.vel);
	    
	    if (tmp.dot(this.vel) > 0) {
	    	if (tmpProj.clone().sub(tmp).length() < blocks[i].radius + 3) {
		      	if (tmpProj.length() < 10 * this.vel.length()) {
		    		this.force.add (tmpProj.clone().sub(tmp).multiplyScalar(10));
		        }
	      	}
	    }
	}
    for (var i=0; i<agentNumber; i++) {
    	if(agents[i].pos === this.pos) {
    		continue;
    	}
	    var tmp = agents[i].pos.clone().sub(this.pos);
	    var tmpProj = tmp.clone().projectOnVector(this.vel);
	    
	    if (tmp.dot(this.vel) > 0) {
	    	if (tmpProj.clone().sub(tmp).length() < 15) {
		      	if (tmpProj.length() < 10 * this.vel.length()) {
		        	//console.log ('block & close');
		    		this.force.add (tmpProj.clone().sub(tmp).multiplyScalar(5));
		    		//break;	
		        }
	      	}
	    }  	
	}
	
    // force clamping
    if (this.force.length() > this.maxForce)
      this.force.setLength(this.maxForce);
    this.vel.add(this.force.clone().multiplyScalar(dt));

    // velocity clamping
    if (this.vel.length() > this.maxSpeed)
      this.vel.setLength(this.maxSpeed);
    this.pos.add(this.vel.clone().multiplyScalar(dt));

    if (this.vel.length() > 0.001) {
      this.angle = Math.atan2(-this.vel.z, this.vel.x);
    }
    this.mesh.position.copy(this.pos);
    this.mesh.rotation.y = this.angle;

    // catch handling
    if (this.pos.distanceTo(this.target) < 2) {
      this.vel.set(0, 0, 0);
      angle = Math.random() * Math.PI * 2;
	}

  }
}

var isAuto = true;
function who() {
	if(!isAuto) {
		document.getElementById('whoSeek').innerHTML = "User";
	} else {
		document.getElementById('whoSeek').innerHTML = "Auto";
	}
	isAuto = !isAuto;
}


init();
animate();

function init() {
	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set (0, 250, 400);
	scene.add(camera);

	var gridXZ = new THREE.GridHelper(planeSize, 20, 'red', 'white');
	//var gridXZ = new THREE.GridHelper(100, 10);
	//gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
	scene.add(gridXZ);

	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);

	controls = new THREE.OrbitControls(camera, renderer.domElement);
	document.body.appendChild(renderer.domElement);

	//////////////////////
	for(var i=0; i<blockNumber; i++) {
		var r = Math.random()*10+10;
		var ob = new THREE.Mesh (new THREE.CircleGeometry (r, 20));
		ob.rotation.x = -Math.PI/2;
		var x = Math.random() * 200 - 100, z = Math.random() * 200 - 100;
		ob.position.set (x, 0, z);
		scene.add (ob);
		blocks.push ({obj: ob, radius: r});
	}

	target.set(50, 0, 50);
	for(var i=0; i<agentNumber; i++) {
		var box = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 5), new THREE.MeshNormalMaterial());
		scene.add(box);
		var p;
		for(var j=0; j<blockNumber; j++) {
			p = new THREE.Vector3(Math.random() * 200 - 100, 0, Math.random() * 200 - 100);
		}
		var agent = new Agent(box, p);
		agent.setTarget(target);
		agents.push (agent);
	}
	puck = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 2, 20), new THREE.MeshNormalMaterial());
	scene.add(puck);
	puck.position.copy (target);



	plane = new THREE.Mesh (new THREE.PlaneBufferGeometry(planeSize*2,planeSize*2), new THREE.MeshBasicMaterial({visible:false}));
	scene.add (plane);
	plane.rotation.x = -Math.PI/2;
	pickables = [plane];

	raycaster = new THREE.Raycaster();
	document.addEventListener('mousedown', onDocumentMouseDown, false);
	window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}


function onDocumentMouseDown(event) {
	// PICKING DETAILS: 
	// convert mouse.xy = [-1,1]^2 (NDC)
	// unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
	// set raycaster (origin, direction)
	// find intersection objects, (closest first) 
	// each record as
	// [ { distance, point, face, faceIndex, object }, ... ]
	/*var p = new THREE.Vector3 (mouse.x, 0, mouse.y);
	var key = false;
	for (var i=0; i<blockNumber; i++) {
		console.log(blocks[i].obj.position.clone().sub(p));
    	if(blocks[i].obj.position.clone().sub(p).length() < blocks[i].radius + 2) {
    		key = true;
    		break;
    	}
    }
    if(!key) {*/
		event.preventDefault();
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

		// find intersections
		raycaster.setFromCamera(mouse, camera);
		var intersects = raycaster.intersectObjects(pickables);
		if (intersects.length > 0) {
			puck.position.copy (intersects[0].point);
			target = intersects[0].point;
		}
	//}

}

function animate() {
	var dt = clock.getDelta(); // delta-time
	for(var i=0; i<agentNumber; i++) {
		agents[i].update(dt);
	}
	

	if(!isAuto) {
		angle += targetOmega * dt;
		target.set(100 * Math.cos(angle), 0, 100 * Math.sin(angle));
	}
	for(var i=0; i<agentNumber; i++) {
		agents[i].setTarget(target);
	}
	puck.position.copy(target);
	

	controls.update();
	requestAnimationFrame(animate);
	render();
}

function render() {
  renderer.render(scene, camera);
}

</script>
</body>
</html>
